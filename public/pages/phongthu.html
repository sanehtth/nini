<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XNC Podcast Studio Pro (V19)</title>
    <link rel="stylesheet" href="/public/style.css">
    <link rel="stylesheet" href="/public/green-theme.css">
    
    <style>
        /* THEME & LAYOUT */
        body { background: linear-gradient(135deg, #CDECC1 0%, #F4E8A2 100%); font-family: 'Segoe UI', sans-serif; color: #5D4037; padding: 20px; height: 100vh; box-sizing: border-box; overflow: hidden; }

        .studio-card {
            background: rgba(255, 255, 255, 0.98); max-width: 1400px; margin: 0 auto; height: 100%;
            border-radius: 20px; box-shadow: 0 20px 50px rgba(139, 94, 60, 0.15); border: 4px solid #fff;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .studio-header {
            background: #8CCB7A; padding: 10px 20px; color: white; border-bottom: 4px solid #B9885D;
            display: flex; justify-content: space-between; align-items: center; gap: 15px; flex-shrink: 0;
        }

        /* PROJECT INFO INPUTS */
        .proj-input { background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; }
        .proj-input::placeholder { color: rgba(255,255,255,0.7); }
        .proj-id { font-family: monospace; font-size: 12px; background: #558B2F; padding: 5px 10px; border-radius: 15px; }

        /* MAIN LAYOUT */
        .main-layout { display: grid; grid-template-columns: 320px 1fr; height: 100%; overflow: hidden; }

        /* SIDEBAR (LIBRARY) */
        .sidebar { background: #F1F8E9; border-right: 1px solid #C5E1A5; display: flex; flex-direction: column; overflow: hidden; }
        
        .tab-bar { display: flex; border-bottom: 1px solid #C5E1A5; background: white; }
        .tab-btn { flex: 1; padding: 10px; border: none; background: none; cursor: pointer; font-weight: bold; color: #777; border-bottom: 3px solid transparent; }
        .tab-btn.active { color: #558B2F; border-bottom-color: #8CCB7A; background: #F9FBE7; }

        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 15px; display: none; }
        .sidebar-content.active { display: block; }

        /* ASSET ITEMS */
        .asset-item {
            background: white; border: 1px solid #DCEDC8; padding: 8px; border-radius: 6px; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center; font-size: 13px; transition: 0.2s;
        }
        .asset-item:hover { border-color: #8CCB7A; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .asset-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .btn-add-mini { background: #8CCB7A; color: white; border: none; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        /* WORKSPACE (TIMELINE) */
        .workspace { background: #FFFDE7; padding: 20px; display: flex; flex-direction: column; overflow: hidden; }

        .track-area { flex-grow: 1; overflow-y: auto; background: white; border: 2px dashed #FFD54F; border-radius: 15px; padding: 20px; position: relative; }
        
        .timeline-block {
            display: flex; align-items: center; padding: 10px; border-radius: 8px; border: 1px solid #ddd;
            background: #FAFAFA; gap: 10px; margin-bottom: 8px; cursor: grab;
        }
        .timeline-block:active { cursor: grabbing; opacity: 0.8; }
        .block-voice { border-left: 5px solid #2196F3; background: #E3F2FD; }
        .block-sfx { border-left: 5px solid #E91E63; background: #FCE4EC; }

        /* FOOTER CONTROLS */
        .footer-ctrl {
            margin-top: 15px; background: #263238; color: white; padding: 15px; border-radius: 15px;
            display: flex; align-items: center; gap: 15px; flex-shrink: 0;
        }
        .btn-main { padding: 10px 20px; border-radius: 30px; border: none; font-weight: bold; cursor: pointer; }
        .btn-play { background: #FF5722; color: white; width: 50px; height: 50px; border-radius: 50%; font-size: 20px; padding: 0; }
        .btn-save { background: #5D4037; color: white; margin-left: auto; }
        .btn-export { background: white; color: #263238; }

        .drop-zone { border: 2px dashed #ccc; padding: 20px; text-align: center; color: #888; border-radius: 10px; margin-bottom: 10px; cursor: pointer; transition: 0.2s; }
        .drop-zone:hover { border-color: #8CCB7A; background: #F1F8E9; color: #33691E; }
    </style>
</head>
<body>

<div class="studio-card">
    <div class="studio-header">
        <div style="display:flex; align-items:center; gap:10px;">
            <h3 style="margin:0">üéõÔ∏è Studio V19</h3>
            <span id="projID" class="proj-id">ID: NEW</span>
            <input type="text" id="projName" class="proj-input" placeholder="T√™n d·ª± √°n (Vd: Tap 1)..." value="Du_An_Moi">
        </div>
        <div style="display:flex; gap:10px;">
            <input type="file" id="loadProjectInput" accept=".xnc" style="display:none" onchange="loadProjectFromFile(this)">
            <button class="btn-main" style="background:#fff; color:#333; font-size:12px; padding:5px 15px;" onclick="document.getElementById('loadProjectInput').click()">üìÇ M·ªü File C≈©</button>
            <div id="apiStatus" style="font-size:11px; background:rgba(255,255,255,0.2); padding:5px 10px; border-radius:10px;">Checking API...</div>
        </div>
    </div>

    <div class="main-layout">
        <div class="sidebar">
            <div class="tab-bar">
                <button class="tab-btn active" onclick="switchTab('library', this)">üìö Th∆∞ Vi·ªán (SFX)</button>
                <button class="tab-btn" onclick="switchTab('tts', this)">üó£Ô∏è T·∫°o Gi·ªçng</button>
            </div>

            <div id="tab-library" class="sidebar-content active">
                <div class="drop-zone" onclick="document.getElementById('bulkUpload').click()">
                    <span style="font-size:24px;">üìÇ</span><br>
                    Click ƒë·ªÉ ch·ªçn nhi·ªÅu file SFX<br>(Ho·∫∑c k√©o th·∫£ v√†o ƒë√¢y)
                </div>
                <input type="file" id="bulkUpload" multiple accept="audio/*" style="display:none" onchange="handleBulkUpload(this)">
                
                <div style="font-size:12px; color:#777; margin-bottom:10px; border-bottom:1px solid #ddd; padding-bottom:5px;">
                    Kho t√†i nguy√™n hi·ªán t·∫°i (<span id="libCount">0</span>):
                </div>
                <div id="libraryList">
                    </div>
            </div>

            <div id="tab-tts" class="sidebar-content">
                <label style="font-size:12px; font-weight:bold;">Nh·∫≠p tho·∫°i:</label>
                <textarea id="ttsInput" rows="4" style="width:100%; border:1px solid #ccc; border-radius:5px; padding:5px; margin-bottom:10px;" placeholder="Nh·∫≠p c√¢u tho·∫°i..."></textarea>
                
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <select id="ttsVoice" style="width:100%; padding:8px; border-radius:5px;">
                        <option value="nova">üë© Nova (N·ªØ d·ªãu d√†ng)</option>
                        <option value="shimmer">üë© Shimmer (N·ªØ s·∫Øc s·∫£o)</option>
                        <option value="onyx">üë® Onyx (Nam tr·∫ßm)</option>
                        <option value="fable">üë® Fable (Nam k·ªÉ)</option>
                        <option value="alloy">üòê Alloy (Trung t√≠nh)</option>
                    </select>
                </div>
                <button class="btn-main" style="width:100%; background:#8CCB7A; color:white;" onclick="generateTTS()">üéôÔ∏è T·∫°o & Th√™m v√†o Timeline</button>
            </div>
        </div>

        <div class="workspace">
            <div style="margin-bottom:15px; display:flex; gap:10px; align-items:center; background:white; padding:10px; border-radius:10px; border:1px solid #E0E0E0;">
                <span style="font-size:20px;">üéµ</span>
                <select id="bgmSelect" style="flex-grow:1; border:none; background:transparent; font-weight:bold; color:#558B2F;">
                    <option value="">-- Ch∆∞a ch·ªçn Nh·∫°c N·ªÅn --</option>
                </select>
                <input type="range" id="bgmVol" min="0" max="1" step="0.1" value="0.3" style="width:100px" title="Volume Nh·∫°c N·ªÅn">
            </div>

            <div class="track-area" id="timelineContainer">
                <div id="emptyMsg" style="text-align:center; color:#ccc; margin-top:100px;">
                    Ch∆∞a c√≥ g√¨ h·∫øt tr∆°n.<br>B·∫•m d·∫•u [+] b√™n th∆∞ vi·ªán ƒë·ªÉ th√™m v√†o nha!
                </div>
                </div>

            <div class="footer-ctrl">
                <button class="btn-play" onclick="playProject()">‚ñ∂</button>
                <div id="statusText" style="font-size:13px;">S·∫µn s√†ng</div>
                
                <button class="btn-main btn-save" onclick="saveProjectToFile()">üíæ L∆∞u D·ª± √Ån (.xnc)</button>
                <button class="btn-main btn-export" onclick="exportAudio()">üì§ Xu·∫•t File Nh·∫°c (.webm)</button>
            </div>
        </div>
    </div>
</div>

<script>
    const PROFILE_ID = "default";
    let openaiKey = "";
    
    // DATA STORE
    let assetsLibrary = []; // [{id, name, blob, type}]
    let timeline = [];      // [{assetId, type, name}]
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    
    // === API KEY SOURCE (per-provider: local/firebase) ===
    const SRC_KEYS = {
        openai: "nini_api_source_openai",
        gemini: "nini_api_source_gemini",
    };

    function getSource(provider) {
        return localStorage.getItem(SRC_KEYS[provider]) || "local";
    }
    function setSource(provider, value) {
        localStorage.setItem(SRC_KEYS[provider], value);
    }

    function getLocalKey(provider) {
        const k = `lq_api_${PROFILE_ID}_${provider}`;
        return localStorage.getItem(k) || "";
    }

    async function getFirebaseKey(provider) {
        try {
            if (!window.auth || !window.db) return "";
            const user = auth.currentUser;
            if (!user) return "";
            const ref = db.ref(`users/${user.uid}/api`);
            const snap = await ref.once("value");
            const val = snap.val() || {};
            return (val[provider] || "").trim();
        } catch (e) {
            console.warn("Firebase key read failed:", e);
            return "";
        }
    }

    async function resolveKey(provider) {
        const mode = getSource(provider);
        if (mode === "firebase") {
            const fb = await getFirebaseKey(provider);
            if (fb) return { key: fb, from: "firebase" };
            const local = getLocalKey(provider);
            return { key: local, from: local ? "local(fallback)" : "none" };
        } else {
            const local = getLocalKey(provider);
            if (local) return { key: local, from: "local" };
            const fb = await getFirebaseKey(provider);
            return { key: fb, from: fb ? "firebase(fallback)" : "none" };
        }
    }

    async function refreshKeyUI() {
        const statusDiv = document.getElementById('apiStatus');
        const hint = document.getElementById('keyHint');

        const selO = document.getElementById("srcOpenAI");
        const selG = document.getElementById("srcGemini");
        if (selO) selO.value = getSource("openai");
        if (selG) selG.value = getSource("gemini");

        const openai = await resolveKey("openai");
        openaiKey = openai.key || "";

        if (statusDiv) {
            statusDiv.innerHTML = openaiKey
              ? `‚úÖ OpenAI key OK (${openai.from})`
              : `‚ö†Ô∏è Ch∆∞a c√≥ OpenAI key (${openai.from})`;
        }

        if (hint) {
            const fbReady = (window.auth && window.db && window.auth.currentUser) ? "Firebase OK" : "Firebase ch∆∞a s·∫µn (ch∆∞a init/login)";
            hint.textContent = fbReady;
        }
    }

    function initKeySourceSelectors() {
        const selO = document.getElementById("srcOpenAI");
        const selG = document.getElementById("srcGemini");

        if (selO) {
            selO.value = getSource("openai");
            selO.addEventListener("change", async () => {
                setSource("openai", selO.value);
                await refreshKeyUI();
            });
        }
        if (selG) {
            selG.value = getSource("gemini");
            selG.addEventListener("change", async () => {
                setSource("gemini", selG.value);
                await refreshKeyUI();
            });
        }
    }


    // INIT
    window.onload = () => {
        // Generate ID
        const pidEl = document.getElementById('projID');
        if (pidEl) pidEl.innerText = "ID: " + Date.now().toString().slice(-6);

        // Init key source selectors + status
        initKeySourceSelectors();
        refreshKeyUI();
    };

    function switchTab(tab, btnEl) {
        document.querySelectorAll('.sidebar-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        document.getElementById('tab-'+tab).classList.add('active');
        if (btnEl) btnEl.classList.add('active');
    }

    // === 1. ASSET MANAGEMENT (LIBRARY) ===
    function handleBulkUpload(input) {
        if(!input.files) return;
        const files = Array.from(input.files);
        
        files.forEach(file => {
            const assetId = "as_" + Date.now() + Math.random().toString(16).slice(2);
            assetsLibrary.push({
                id: assetId,
                name: file.name,
                blob: file,
                type: 'sfx'
            });
        });
        
        renderLibrary();
        input.value = ""; // reset
    }

    function renderLibrary() {
        const list = document.getElementById('libraryList');
        const bgmSel = document.getElementById('bgmSelect');
        const currentBgm = bgmSel.value;

        list.innerHTML = "";
        bgmSel.innerHTML = '<option value="">-- Ch·ªçn l√†m Nh·∫°c N·ªÅn --</option>';
        
        document.getElementById('libCount').innerText = assetsLibrary.length;

        assetsLibrary.forEach(asset => {
            // Render List Item
            const div = document.createElement('div');
            div.className = 'asset-item';
            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:5px;">
                    <span style="font-size:16px;">${asset.type==='voice'?'üó£Ô∏è':'üîä'}</span>
                    <div class="asset-name" title="${asset.name}">${asset.name}</div>
                </div>
                <div style="display:flex; gap:5px;">
                    <button class="btn-add-mini" style="background:#BCAAA4" onclick="previewAsset('${asset.id}')">‚ñ∂</button>
                    <button class="btn-add-mini" onclick="addToTimeline('${asset.id}')">‚úö</button>
                </div>
            `;
            list.appendChild(div);

            // Render BGM Option
            const opt = document.createElement('option');
            opt.value = asset.id;
            opt.text = asset.name;
            bgmSel.appendChild(opt);
        });

        bgmSel.value = currentBgm;
    }

    function previewAsset(id) {
        const asset = assetsLibrary.find(a => a.id === id);
        if(asset) {
            const url = URL.createObjectURL(asset.blob);
            new Audio(url).play();
        }
    }

    // === 2. TTS GENERATION ===
    async function generateTTS() {
        const text = document.getElementById('ttsInput').value;
        // Ensure key loaded (OpenAI)
        if (!openaiKey) {
            try {
                const r = await resolveKey('openai');
                openaiKey = r.key || '';
            } catch (_) {}
        }
        const voice = document.getElementById('ttsVoice').value;
        if(!text || !openaiKey) return alert("Ki·ªÉm tra n·ªôi dung ho·∫∑c API Key!");

        document.getElementById('statusText').innerText = "ƒêang t·∫°o gi·ªçng...";
        
        try {
            const response = await fetch("https://api.openai.com/v1/audio/speech", {
                method: "POST",
                headers: { "Authorization": `Bearer ${openaiKey}`, "Content-Type": "application/json" },
                body: JSON.stringify({ model: "tts-1", input: text, voice: voice })
            });
            const blob = await response.blob();
            
            // Add to Library first
            const assetId = "voice_" + Date.now();
            assetsLibrary.push({
                id: assetId,
                name: `[${voice}] ${text.substring(0,15)}...`,
                blob: blob,
                type: 'voice'
            });
            
            renderLibrary();
            addToTimeline(assetId); // Add directly
            
            document.getElementById('ttsInput').value = "";
            document.getElementById('statusText').innerText = "ƒê√£ xong!";
        } catch(e) { alert(e.message); }
    }

       
    // === 3. TIMELINE LOGIC (FIXED) ===
    function addToTimeline(assetId) {
        const asset = assetsLibrary.find(a => a.id === assetId);
        if (!asset) return;
        timeline.push({ assetId: asset.id });
        renderTimeline();
    }

    function removeTimelineItem(index) {
        if (index < 0 || index >= timeline.length) return;
        timeline.splice(index, 1);
        renderTimeline();
    }

    function moveItem(index, dir) {
        const target = index + dir;
        if (target < 0 || target >= timeline.length) return;
        [timeline[index], timeline[target]] = [timeline[target], timeline[index]];
        renderTimeline();
    }

    function renderTimeline() {
        const container = document.getElementById('timelineContainer');
        container.innerHTML = "";

        if (timeline.length === 0) {
            container.innerHTML = `
                <div id="emptyMsg" style="text-align:center; color:#ccc; margin-top:100px;">
                    Ch∆∞a c√≥ g√¨ h·∫øt tr∆°n.<br>B·∫•m d·∫•u [+] b√™n th∆∞ vi·ªán ƒë·ªÉ th√™m v√†o nha!
                </div>`;
            return;
        }

        timeline.forEach((item, index) => {
            const asset = assetsLibrary.find(a => a.id === item.assetId);
            if (!asset) return;

            const div = document.createElement('div');
            div.className = 'timeline-item';
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                  <b>${index+1}. ${asset.name}</b>
                  <div style="display:flex; gap:6px; align-items:center;">
                    <button class="btn-mini" onclick="moveItem(${index}, -1)" title="L√™n">‚¨Ü</button>
                    <button class="btn-mini" onclick="moveItem(${index},  1)" title="Xu·ªëng">‚¨á</button>
                    <button style="border:none; background:none; cursor:pointer; color:#f44336; font-weight:bold; margin-left:10px;" onclick="removeTimelineItem(${index})" title="Xo√°">‚úñ</button>
                  </div>
                </div>
                <div style="font-size:12px; opacity:.75; margin-top:4px;">${asset.type.toUpperCase()}</div>
            `;
            container.appendChild(div);
        });
    }

function saveProjectToFile() {
        const name = document.getElementById('projName').value || "Project";
        const btn = document.querySelector('.btn-save');
        btn.innerText = "‚è≥ ƒêang n√©n...";

        // Convert all blobs to Base64 to save in JSON (Simple logic for small projects)
        // Warning: Large files will make this slow.
        const serializedAssets = await Promise.all(assetsLibrary.map(async (a) => {
            return {
                id: a.id,
                name: a.name,
                type: a.type,
                data: await blobToBase64(a.blob)
            };
        }));

        const projectData = {
            meta: {
                id: document.getElementById('projID').innerText,
                name: name,
                date: new Date().toISOString()
            },
            timeline: timeline,
            assets: serializedAssets,
            bgmId: document.getElementById('bgmSelect').value,
            bgmVol: document.getElementById('bgmVol').value
        };

        const blob = new Blob([JSON.stringify(projectData)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${name}.xnc`; // Custom extension
        link.click();
        
        btn.innerText = "üíæ L∆∞u D·ª± √Ån (.xnc)";
        alert("ƒê√£ l∆∞u! H√£y gi·ªØ file .xnc n√†y c·∫©n th·∫≠n.");
    }

    function loadProjectFromFile(input) {
        const file = input.files && input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const data = JSON.parse(e.target.result);

                // Restore Meta
                document.getElementById('projName').value = data.meta?.name || "PhongTh∆∞";
                document.getElementById('projID').innerText = data.meta?.id || ("ID: " + Date.now().toString().slice(-6));
                document.getElementById('bgmVol').value = (data.bgmVol ?? 0.3);

                // Restore Assets
                assetsLibrary = await Promise.all((data.assets || []).map(async (a) => {
                    // stored as dataURL
                    const resp = await fetch(a.dataURL || a.data);
                    const blob = await resp.blob();
                    return { id: a.id, name: a.name, blob, type: a.type };
                }));

                // Restore Timeline
                timeline = Array.isArray(data.timeline) ? data.timeline : [];

                // Restore BGM selection
                if (data.bgmId) document.getElementById('bgmSelect').value = data.bgmId;

                renderAssets();
                renderTimeline();
                alert("ƒê√£ kh√¥i ph·ª•c d·ª± √°n th√†nh c√¥ng!");
            } catch (err) {
                console.error(err);
                alert("File l·ªói ho·∫∑c h·ªèng: " + err.message);
            } finally {
                input.value = "";
            }
        };
        reader.readAsText(file);
    }

function playProject(isExport = false) {
        if(timeline.length === 0) return alert("Timeline tr·ªëng!");
        if (audioContext && audioContext.state === "suspended") { audioContext.resume(); }
        const status = document.getElementById('statusText');
        status.innerText = isExport ? "ƒêang xu·∫•t file..." : "ƒêang ph√°t...";
        
        const dest = audioContext.createMediaStreamDestination();
        let mediaRecorder, chunks = [];

        if(isExport) {
            mediaRecorder = new MediaRecorder(dest.stream);
            mediaRecorder.ondataavailable = e => chunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { 'type' : 'audio/webm; codecs=opus' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${document.getElementById('projName').value}.webm`;
                a.click();
                status.innerText = "‚úÖ ƒê√£ xong!";
            };
            mediaRecorder.start();
        }

        // Play BGM
        const bgmId = document.getElementById('bgmSelect').value;
        let bgmSource;
        if(bgmId) {
            const asset = assetsLibrary.find(a => a.id === bgmId);
            if(asset) {
                const buf = await asset.blob.arrayBuffer().then(b => audioContext.decodeAudioData(b));
                bgmSource = audioContext.createBufferSource();
                bgmSource.buffer = buf;
                bgmSource.loop = true;
                const gain = audioContext.createGain();
                gain.gain.value = document.getElementById('bgmVol').value;
                bgmSource.connect(gain);
                gain.connect(dest);
                if(!isExport) gain.connect(audioContext.destination);
                bgmSource.start(0);
            }
        }

        // Play Timeline
        for (const item of timeline) {
            const asset = assetsLibrary.find(a => a.id === item.assetId);
            if(asset) {
                // Clone buffer logic
                const arrayBuffer = await asset.blob.slice(0).arrayBuffer(); // Clone blob
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(dest);
                if(!isExport) source.connect(audioContext.destination);
                source.start(0);
                await new Promise(r => setTimeout(r, (audioBuffer.duration * 1000) + 100));
            }
        }

        if(bgmSource) bgmSource.stop();
        if(isExport && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        if(!isExport) status.innerText = "Ho√†n t·∫•t";
    }

    function exportAudio() { playProject(true); }

</script>

</body>
</html>

